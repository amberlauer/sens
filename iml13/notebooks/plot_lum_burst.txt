!!ACL!! declare function and variables used when calling function

subroutine do_burst_plot(s, device_id, &
            winxmin, winxmax, winymin, winymax, label_scale, ierr)
    !!ACL!! link to libraries
    use utils_lib
    use const_def
    
    !!ACL!! declare variables
    type (star_info), pointer :: s
       integer, intent(in) :: device_id
    real, intent(in) :: winxmin, winxmax, winymin, winymax, label_scale
    integer, intent(out) :: ierr
        
    real :: windy, xmargin
    real :: xmin, xmax, xleft, xright, dx, tmp, ymin, ymax, dy
       integer :: grid_min, grid_max, npts, nz
    real, pointer, dimension(:) :: xvec, yvec
         
    logical :: dbg = .false.
         
    include 'formats.inc'
    ierr = 0
    xmargin = 0
    !!ACL!! allocate arrays declared above, initialize first entry)
    allocate (xvec(1:s% model_number), yvec(1:s% model_number))
    
    !!ACL!! call subroutine that does the graphing
    call plot(ierr)
    !!ACL!! check for general error conditon
    if (ierr /= 0) return
    
    !!ACL!! release memory that was holding array.
    deallocate(xvec, yvec)

    !!!!! end !!!!!!!             
    contains
!!ACL!! subroutines called above, where the magic actually happens
        subroutine plot(ierr)
            !!ACL!! link more libs
            use crlibm_lib, only: safe_log10_cr

            !!ACL!! declare more vars
            integer, intent(out) :: ierr
            integer :: i,j
            
            integer :: lw, lw_sav, k,n,report,ix,iy
            real :: ybot, eps
         
			real :: shift1
			integer,dimension(1) :: shift
			integer :: start,endP
			logical :: start_flag
			character(len=2) ::  yScaleLabel 
         
            include 'formats.inc'
            ierr = 0

            !!ACL!! s% is the array that holds all the MESA variables. So if you see it in the history or profile, it's probably in s% and will be called by name with s% at the beginning
			n=s%model_number
         
            !!ACL!! probably a function to save the images as png. 
            call pgsave
            
            !!ACL!!
            lw = 6

            !!ACL!! I believe these are passing on plot limit setting from inlist_for_my_pgstar
            call pgqlw(lw_sav)
            
            call pgsvp(winxmin, winxmax, winymin, winymax)
            
			!!ACL!! functions to show info on the plot- Labels
			call pgsci(1)
			call pgstar_show_title(s,'Burst Profile',0.0)
			call pgstar_show_xaxis_label(s,'Time [s]',0.0)
			call pgstar_show_model_number(s)
			call pgstar_show_age(s)
			
			!Y axis label
			if(burst_scale_lum)THEN
				call pgstar_show_left_yaxis_label(s,'Flux',0.0)
			else
				Write(yScaleLabel, '(I2)')  y_scale_factor
				call pgstar_show_left_yaxis_label(s,'Luminosity [10**'//trim(yScaleLabel)//']',0.0)
			end if
            
            !left axis

            if (burst_ymax_left > -100) then
               ymax = burst_ymax_left
            else
               ymax = 1.0
            end if
            
            if (burst_ymin_left > -100) then
               ymin = burst_ymin_left
            else
               ymin = 0.0
            end if
            
            
            if (burst_xmax > -100) then
               xright = burst_xmax
            else
               xright= 150.0
            end if
            
            if (burst_xmin > -100) then
               xleft = burst_xmin
            else
               xleft = -20.0
            end if
            
			shift=maxloc(gs_flux)
			shift1=gs_time(shift(1))
			
            !!ACL!! gs_flux is a plot of the luminosity for a real XRB, it is used for reference on the plot. Since flux is really distance dependent, you can rescale bursts 

			gs_flux=gs_flux/maxval(gs_flux)
				
			if(burst_scale_lum)THEN
			    gs_flux=gs_flux
			else
				gs_flux=(gs1826_lum/(10.0**y_scale_factor))*gs_flux
			end if
				
            ! write(*,*) xleft*1.0, xright*1.0, ymin*1.0, maxval(gs_flux),gs1826_lum,10.0**(y_scale_factor)
			call pgswin(xleft*1.0, xright*1.0, ymin*1.0, maxval(gs_flux))
				
			call pgscf(1)
            call pgsci(1)
            call pgstar_show_box(s,'BCNST','BCNSTV')
            
            !!ACL!! setting to choose whether to show reference burst
            if(show_gs1826) THEN
				call pgsci(clr_Teal)
				call pgslw(lw)
				
				call pgline(size(gs_time),gs_time-shift1,gs_flux)
				call pgslw(lw_sav)
			end if
            
			!!ACL!! get the info for plot from history data
			call integer_dict_lookup(s% history_names_dict, 'star_age', ix, ierr)
			call get_hist_points2(s,1,s%model_number,n,ix,xvec)
			
			call integer_dict_lookup(s% history_names_dict, 'log_L', iy, ierr)
			call get_hist_points2(s,1,s%model_number,n,iy,yvec)

			if(ix==0 .or. iy==0 .or. s%model_number<=2) THEN
				ierr=0			
				return
			end if
				
			yvec=(10**yvec)/redshift
			xvec=(xvec*3600.0*24.0*365.0)*redshift



            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!ACL!! this is the really important part but you have to have a good understanding of the variables created above to follow this
			!Logic to find peak(s) when L(i-1)<10*L(i)
			i=2
			start=-1
			endP=-1
			do 
				start_flag=.false.
				if(i>=s%model_number-1) EXIT
				!start=-1
				!endP=-1
				do j=min(max(1,start+1),i),i
					if(xvec(i)+(xleft) < xvec(j) .and. yvec(i)>flux_change*yvec(j))THEN
						start=i
						start_flag=.true.
						exit
					end if
				end do
				!write(*,*) s%model_number,i,j,start,start_flag
				
				if(start_flag) THEN
					endP=s%model_number
					do j=start+1,s%model_number
						!if(xvec(s%model_number)<=xvec(start)+(xright+50.0))THEN
						if( xvec(j) > xvec(start)+(xright+50.0) )THEN
							endP=j
							exit
						end if
					end do
				end if
					
				if(start_flag)THEN
					shift=maxloc(yvec(start:endP))
					shift1=xvec(shift(1)+start-1)
					call pgsci(clr_LightGray)
					call pgslw(lw)
					
					if(burst_scale_lum) THEN
						yvec(start:endP)=yvec(start:endP)/maxval(yvec(start:endP))
					else
						yvec(start:endP)=lsol*yvec(start:endP)/(10.0**y_scale_factor)
					end if
					
					call pgline(endP-start,xvec(start:endP)-shift1,yvec(start:endP))

					call pgslw(lw_sav)
					i=endP+1
				else
					i=i+1
				end if
			end do
            !!ACL!! end of important bit	    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            


            
            call pgunsa
            
        end subroutine plot    
         
end subroutine do_burst_plot